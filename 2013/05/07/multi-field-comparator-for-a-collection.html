<!DOCTYPE html><html class=no-js><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Multi-field comparator for a collection</title><meta name=description content=""><meta name=viewport content="width=device-width, initial-scale=1"><link rel=stylesheet href=/css/main.6f42.css><script src=/js/head-scripts.a52a.js></script></head><body><header class=page__header><div class=header-wrapper><h1>Joel Herron</h1><h2>Web &amp; Mobile Designer/Developer</h2></div></header><nav class="nav site-nav"><a href="/">about</a> <a href=/#blog>blog</a> <a href=/#projects>projects</a></nav><article class=post><h1 class=post__title>Multi-field comparator for a collection</h1><p class=post__meta><span class=brand-color>Filed under:</span> mobile <span class=brand-color>Tagged:</span> alloy, backbonejs, and collections<br>07 May, 2013</p><p>There are many times when being able to sort a collection against two or more distinct columns is needed. Unfortunately Backbone doesn&#39;t provide a default way to do that via the comparator function. However, making it happen inside our collection definition is quite straight forward.</p><p>For my example I&#39;ll be sorting a list of cities and states. The end result we want is to have a list of cities sorted by state.</p><p>With the default comparator we get one or the other sorted cities or states.</p><div class=highlight><pre><code class=javascript><span class=nx>comparator</span><span class=o>:</span> <span class=kd>function</span><span class=p>(</span><span class=nx>Model</span><span class=p>){</span>
  <span class=k>return</span> <span class=nx>Model</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;city&#39;</span><span class=p>);</span>
  <span class=c1>// or</span>
  <span class=c1>// return Model.get(&#39;state&#39;);</span>
<span class=p>}</span>
</code></pre></div><p>To get at multiple we need to understand what the comparator function is actually doing. Backbone uses the <code>sortBy()</code> function to prepare the collection in a always ordered stack(it&#39;s not really a stack but go with me on it). Running a compare on a collection returns a -1, 0, or 1 based on where the model should be placed compared to the models it&#39;s compared to, thus keeping the collection in a ordered state by moving the order based on the result.</p><p>In order to sort on multiple columns we need to give backbone a result that can be sorted that utilizes both columns/fields values. The best way I&#39;ve found is to use a normalized string. In our city and state example our data is all alphabetical so sorting against them will be easy. If your data set is numerical, however be careful that all your numerals are the same length, i.e. 002, 100, 045. other wise you will get mismatches in the compare.</p><p>Now our comparator looks like this:</p><div class=highlight><pre><code class=javascript>  <span class=nx>comparator</span><span class=o>:</span> <span class=kd>function</span><span class=p>(</span><span class=nx>Model</span><span class=p>){</span>
    <span class=kd>var</span> <span class=nx>location</span> <span class=o>=</span> <span class=nx>Model</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;state&#39;</span><span class=p>)</span> <span class=o>+</span> <span class=s1>&#39;-&#39;</span> <span class=o>+</span> <span class=nx>Model</span><span class=p>.</span><span class=nx>get</span><span class=p>(</span><span class=s1>&#39;city&#39;</span><span class=p>);</span>
    <span class=k>return</span> <span class=nx>location</span><span class=p>;</span>
  <span class=p>}</span> 
</code></pre></div><p>Which will return strings like &#39;WI-Madison&#39;, &#39;WI-Milwaukee&#39;. By putting the <code>Model.get(&#39;state&#39;)</code> first I&#39;m able to sort on state before dealing with individual cities, thus getting me my end result.</p><p>Using the same approach you can now sort on as many columns or attributes as needed and get the results you want. The key is remembering how the comparator works by ensuring you return a string that can be uniquely sorted. With this rule in mind you can finally do some advanced sorting on your collections.</p><div id=disqus_thread></div><script type=text/javascript>/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
				var disqus_shortname = 'h3r2on';
				var disqus_identifier = 'multi-field-comparator-for-a-collection';
				var disqus_title = 'Multi-field comparator for a collection';
				/* * * DON'T EDIT BELOW THIS LINE * * */
				(function() {
						var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
						dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
						(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				})();</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=http://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article><script src=//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js></script><script>window.jQuery || document.write('<script src="/_bower_components/jquery.js"><\/script>')</script><script src=/js/script.d16b.js></script><!-- Google Analytics: change UA-XXXXX-X to be your site's ID. --><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
  function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
  e=o.createElement(i);r=o.getElementsByTagName(i)[0];
  e.src='//www.google-analytics.com/analytics.js';
  r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
  ga('create','UA-XXXXX-X');ga('send','pageview');</script></body></html>